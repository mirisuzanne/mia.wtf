<!doctype html>
<html lang="en" data-theme="auto">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Everything `as:video-cast`</title>

    <script async>
      const THEME_KEY = 'theme';
      const storedValue = localStorage.getItem(THEME_KEY);

      if (storedValue) {
        document.documentElement.dataset[THEME_KEY] = storedValue;
      }
    </script>

    <!-- <meta webc:is="site-styles" webc:nokeep> -->
    <meta name="color-scheme" content="dark light">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="hotpink">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="mediumvioletred">


    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#a71f63">
<meta name="msapplication-TileColor" content="#f4f0f2">

    <link href="https://screenshot-api.miriam.codes" rel="preconnect" crossorigin>
<meta property="og:type" content="website">
<meta property="og:title">
<meta property="og:image" content="https://screenshot-api.miriam.codes/http%3A%2F%2Flocalhost%3A8080%2Ftags%2Fas%3Avideo-cast%2F/opengraph/">
<meta property="og:url" content="/tags/as:video-cast/">
<meta property="og:site_name" content="Mia Culpa">
<meta property="og:description" content="Art &amp; CSS &amp; other digital artifacts of my life">
<meta name="description" content="Art &amp; CSS &amp; other digital artifacts of my life">


    <!-- <link
      rel="preload"
      href="/fonts/alegreya-latin-wght-normal.woff2"
      as="font"
      type="font/woff2"
      crossorigin> -->
  </head>
  <body>
    <div skip-link><a href="#main">skip to content</a></div>

    <dialog in-flow data-layout id="theme-controls">
  <form method="dialog">
    <button>
      <emo-ji aria-hidden="true">❎</emo-ji>
      <span>close</span>
    </button>
  </form>
  <h2>Colors</h2>
<toggle-control data-attr="theme" data-local="css.theme">


  <button data-value="browser">browser</button>
  <button data-value="legacy">legacy</button>
  <button data-value="mia" aria-pressed="true">mia</button>
</toggle-control>

<toggle-control data-prop="color-scheme" data-local="css.light-dark">


  <button data-value="dark light" aria-pressed="true">auto</button>
  <button data-value="dark">dark</button>
  <button data-value="light">light</button>
</toggle-control>

<h2>Text</h2>
<toggle-control data-for="body" data-prop="font-size" data-local="css.font-size">


  <button data-value="small">small</button>
  <button data-value="medium">medium</button>
  <button data-value="large" aria-pressed="true">large</button>
  <button data-value="x-large">x-large</button>
  <button data-value="xx-large">xx-large</button>
</toggle-control>

<input-control data-prop="line-height" data-local="css.line-height">


  <label for="line-height">Line Height</label>
  <input id="line-height" type="range" min="1" max="2" step="0.01" value="1.48">
  <output for="line-height"></output>
</input-control>

<h2>Site Styles</h2>
<css-toggle><button type="button" is-switch aria-pressed="true"><switch-text>All styles</switch-text></button>





</css-toggle>

</dialog>

<header>
  <a href="/" rel="home">
    <emo-ji aria-hidden="true">👩🏼‍🎤</emo-ji>
    <link-text>mia</link-text>
  </a>
  <dialog-toggle><button aria-controls="theme-controls">
    <emo-ji aria-hidden="true">🎨</emo-ji>
    <span>theme</span>
  </button>


</dialog-toggle>
</header>

<main id="main" tabindex="-1" data-layout>

<hr aria-hidden="true">

<header data-layout="page-header">
  <title-group><h1 id="title">Everything <code>as:video-cast</code></h1>

<div class="subtitle"><p><a href="/tags/">see all tags</a></p>



</div>
</title-group>
</header>

<div data-layout="content">


<ul>
  <li>
    <a href="/web/teaching/winging-it/">Winging It</a>
  </li>
</ul>
</div>


</main>

<site-footer id="content-info" data-layout><footer>
  <p>
    ©
    <em>Miriam Eric Suzanne</em>,
    <time>2024</time>
  </p>

  <nav>
    <nav-link href="/about/">
      <emo-ji aria-hidden="true">👩🏼‍🎤</emo-ji>
      <link-text>/about</link-text>
    </nav-link>

    <nav-link href="/follow/">
      <emo-ji aria-hidden="true">📡</emo-ji>
      <link-text>/follow</link-text>
    </nav-link>

    <nav-link href="/why/">
      <emo-ji aria-hidden="true">⁉️</emo-ji>
      <link-text>/why</link-text>
    </nav-link>

    <nav-link href="/contact/">
      <emo-ji aria-hidden="true">💬</emo-ji>
      <link-text>/contact</link-text>
    </nav-link>
  </nav>

  <a href="/_og/tags/as:video-cast/">(social image)</a>
</footer>
</site-footer>




    <script type="module">class GroundControl extends HTMLElement {
  static register(tagName) {
    if ('customElements' in window) {
      customElements.define(
        tagName || 'ground-control',
        GroundControl
      );
    }
  }

  static observedAttributes = [
    'data-for', // <selector-list> of elements to update…
    // by setting either…
    'data-attr', // <attribute-name>
    'data-prop', // <css-property-name>
    // and optionally storing the value for later…
    'data-local', // <localStorage key>
    'data-session', // <sessionStorage key>
    // override event listeners (mainly for inputs)
    'data-event',
    // provide an 'off' value (mainly for toggles)
    'data-off',
  ];

  static _appendShadowTemplate = (node) => {
    const template = document.createElement('template');
    const shadowRoot = node.attachShadow({ mode: 'open' });
    template.innerHTML = `<slot></slot>`;
    shadowRoot.appendChild(template.content.cloneNode(true));
  }
  static _adoptShadowStyles = (node) => {
    const shadowStyle = new CSSStyleSheet();
    shadowStyle.replaceSync(`:host { display: block }`);
    node.shadowRoot.adoptedStyleSheets = [shadowStyle];
  }

  static blockDisplay = (node) => {
    GroundControl._appendShadowTemplate(node);
    GroundControl._adoptShadowStyles(node);
  };

  #related = {};
  #inputId;
  #currentValue;
  hasInput;
  initialValue;

  constructor() {
    super();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (newValue === oldValue) return;

    switch (name) {
      case 'data-for':
        this.targets = newValue;
        break;
      case 'data-local':
        localStorage.removeItem(oldValue);
        break;
      case 'data-session':
        sessionStorage.removeItem(oldValue);
        break;
      case 'data-event':
        if (this.onEventChange) this.onEventChange();
        break;
    }
    this.broadCast();
  }

  connectedCallback() {
    this.targets = this.dataset.for;
  }

  disconnectedCallback() {
    this.#removeResetListener();
  }

  // getters and setters
  set value(newValue) {
    this.#currentValue = newValue;
    if (this.onValueChange) this.onValueChange();
    this.broadCast();
  }

  get value() { return this.#currentValue; }
  get usedValue() { return this.value || this.dataset.off; }

  set inputId(value) {
    this.#inputId = value;

    this.#removeResetListener();
    this.#related.resets = this.#findAll(
      `button[data-reset~=${value}]`
    );
    this.#addResetListener();

    this.#related.displays = this.#findAll(
      `output[for=${value}]`
    );
  }

  get inputId() { return this.#inputId; }

  set targets(to) {
    this.#related.targets = (to && typeof to === 'object')
      ? to
      : this.#findAll(to || ':root');
  }

  get targets() { return this.#related.targets || []; }
  get displays() { return this.#related.displays || []; }

  get storedValue() {
    return sessionStorage.getItem(this.dataset.session)
      || localStorage.getItem(this.dataset.local);
  }

  set storedValue(value) {
    const clearWhen = [
      this.initialValue,
      undefined, 'undefined',
    ];

    this.#updateStorage(clearWhen.includes(value));
  }

  // public methods
  onValueChange;
  onEventChange;

  onReset = () => {
    this.value = this.initialValue;
  };

  broadCast = () => {
    if (!this.hasInput) { return; }
    this.storedValue = this.value;

    this.targets.forEach((el) => {
      if (this.dataset.prop) {
        if (this.usedValue) {
          el.style.setProperty(this.dataset.prop, this.usedValue);
        } else {
          el.style.removeProperty(this.dataset.prop);
        }
      }
      if (this.dataset.attr) {
        if (this.usedValue) {
          el.setAttribute(this.dataset.attr, this.usedValue);
        } else {
          el.removeAttribute(this.dataset.attr);
        }
      }
    });

    this.displays.forEach((el) => {
      el.value = this.usedValue;
    });
  };

  #updateStorage = (clear) => {
    if (this.dataset.local) {
      clear
        ? localStorage.removeItem(this.dataset.local)
        : localStorage.setItem(this.dataset.local, this.value);
    }

    if (this.dataset.session) {
      clear
        ? sessionStorage.removeItem(this.dataset.session)
        : sessionStorage.setItem(this.dataset.session, this.value);
    }
  }

  // private methods
  #findAll = (selector) => [
    ...document.querySelectorAll(selector)
  ];

  #addResetListener = () => {
    this.#related.resets.forEach((resetBtn) => {
      resetBtn.addEventListener('click', this.onReset);
    });
  }

  #removeResetListener = () => {
    if (!this.#related.resets) { return; }

    this.#related.resets.forEach((resetBtn) => {
      resetBtn.removeEventListener('click', this.onReset);
    });
  }
}
class ToggleControl extends GroundControl {
  static register(tagName) {
    if ('customElements' in window) {
      customElements.define(
        tagName || 'toggle-control',
        ToggleControl
      );
    }
  }

  toggles = [];

  set pressed(target) {
    this.toggles.forEach((btn) => {
      btn.setAttribute(
        'aria-pressed',
        target === btn ? 'true' : 'false'
      );
    });
  }

  get pressed() {
    return this.toggles.find(
      (btn) => btn.getAttribute('aria-pressed') === 'true'
    );
  }

  get pressedValue() {
    return this.pressed?.dataset.value;
  }

  constructor() {
    super();
    GroundControl.blockDisplay(this);
    this.addEventListener('click', this.onTogglePress);
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.id) this.inputId = this.id;

    this.toggles = this.#findToggles();

    if (!this.toggles) {
      console.error('No toggle buttons found for toggle-control');
      return;
    }

    this.hasInput = true;

    this.toggles.forEach((btn) => {
      btn.setAttribute('type', 'button');

      if (!btn.dataset.value) {
        btn.dataset.value = btn.innerText;
      }
    });

    this.pressed = this.pressed;
    this.initialValue = this.pressedValue || this.dataset.off;

    this.value = this.storedValue || this.initialValue;
  }

  onTogglePress = (event) => {
    this.doPress(event.target);
    this.value = this.pressedValue;
  }

  onValueChange = () => {
    if (this.usedValue !== this.pressedValue) {
      this.pressed = this.#toggleFromValue();
    }
  }

  doPress = (target) => {
    if (!this.toggles.includes(target)) return;

    const isUnPress = this.pressed === target;
    const allowUnPress = this.dataset.off || this.toggles.length === 1;

    if (isUnPress && allowUnPress) {
      this.pressed = undefined;
    } else {
      this.pressed = target;
    }
  }

  #toggleFromValue = () => this.toggles.find(
    (btn) => btn.dataset.value === this.usedValue
  );

  #findToggles = () => [
    ...this.querySelectorAll('button:not([for-reset])')
  ];
}

ToggleControl.register();
class InputControl extends GroundControl {
  static register(tagName) {
    if ('customElements' in window) {
      customElements.define(
        tagName || 'input-control',
        InputControl
      );
    }
  }

  static rejectInputTypes = [
    'file',
    'submit', 'reset', 'button', 'image',
    'checkbox', 'radio'
  ];

  #input;

  constructor() {
    super();
    GroundControl.blockDisplay(this);

    this.addEventListener('change', this.onInputChange);
    this.addEventListener('input', this.onInputChange);
  }

  connectedCallback() {
    super.connectedCallback();
    this.#input = this.#findInput();

    if (!this.#input) {
      console.error('No input found for input-control');
      return;
    }

    this.hasInput = true;
    if (this.#input.id) this.inputId = this.#input.id;

    this.initialValue = this.#input.value;
    this.value = this.storedValue || this.initialValue;
  }

  onInputChange = (event) => {
    const onType = this.dataset.event || 'change';
    if (onType !== event.type) return;

    this.value = this.#input.value;
  }

  onValueChange = () => {
    this.#input.value = this.value;
  }

  #findInput = () => {
    const inputSelect = InputControl.rejectInputTypes.reduce(
      (all, type) => {
        const item = `[type=${type}]`;
        return all ? `${all}, ${item}` : item;
      }
    );

    return this.querySelector(`select, input:not(${inputSelect})`);
  }
}

InputControl.register();
class SwitchControl extends GroundControl {
  static register(tagName) {
    if ("customElements" in window) {
      customElements.define(tagName || "switch-control", SwitchControl);
    }
  }

  static observedAttributes = [
    ...super.observedAttributes,
    'data-on',
    'data-id',
  ];

  #toggle;
  target;

  onPress;
  onUnPress;

  get toggle() { return this.#toggle; }

  set toggle(el) {
    if (!el) throw 'A toggle is required';
    if (el.tagName !== 'BUTTON') throw 'The toggle must be a button';
    if (this.#toggle) this.#removeToggleListener(this.#toggle);

    el.setAttribute('type', 'button');
    if (!el.hasAttribute('aria-pressed')) {
      el.setAttribute('aria-pressed', 'false');
    }

    this.#toggle = el;

    this.initialValue = this.pressed;
    this.#addToggleListener(el);
    if (el.id) this.inputId = el.id;
    this.hasInput = true;
    if (!this.dataset.on) {
      this.dataset.on = el.dataset.value || el.innerText;
    }
  }

  get pressed() {
    return this.toggle.getAttribute('aria-pressed') === 'true';
  };

  set pressed(to) {
    this.toggle.setAttribute('aria-pressed', to ? 'true' : 'false');
  };

  constructor() {
    super();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);

    switch (name) {
      case 'data-id':
        this.#findToggle();
        break;
    }

    this.toggleActions();
  }

  connectedCallback() {
    super.connectedCallback();
    this.#findToggle();
    this.toggleActions();
  }

  disconnectedCallback() {
    this.#removeToggleListener(this.toggle);
  }

  togglePress = () => {
    this.pressed = !this.pressed;
    this.toggleActions();
  }

  toggleActions = () => {
    if (!this.toggle) return;

    this.value = this.pressed
      ? this.dataset.on
      : this.dataset.off;

    if (this.pressed && this.onPress) this.onPress();
    if (!this.pressed && this.onUnPress) this.onUnPress();
  }

  onReset = () => {
    this.pressed = this.initialValue;
    this.toggleActions();
  };

  #findToggle = () => {
    const foundToggle = this.dataset.id
      ? this.querySelector(`button[id='${this.dataset.id}']`)
      : this.querySelector('button');

    this.toggle = foundToggle;
  }

  #addToggleListener = (el) => {
    el.addEventListener('click', this.togglePress);
  }

  #removeToggleListener = (el) => {
    el.removeEventListener('click', this.togglePress);
  }
}

SwitchControl.register();
class CSSToggle extends SwitchControl {
  static register(tagName) {
    if ('customElements' in window) {
      customElements.define(tagName || 'css-toggle', CSSToggle);
    }
  }

  set CSS(enable) {
    const embed = document.querySelectorAll('style');
    const link = document.querySelectorAll('link[rel=stylesheet]');
    const styles = [...embed, ...link];

    styles.forEach((sheet) => sheet.disabled = !enable);

    const inline = document.querySelectorAll('[style], [data-style]');
    inline.forEach((el) => {
      if (enable) {
        el.setAttribute('style', el.dataset.style);
        el.removeAttribute('data-style');
      } else {
        el.dataset.style = el.getAttribute('style');
        el.removeAttribute('style');
      }
    })
  };

  constructor() {
    super();
    this.onPress = () => this.CSS = true;
    this.onUnPress = () => this.CSS = false;
  }
}

CSSToggle.register();
class DialogToggle extends HTMLElement {
    static register(tagName) {
      if ('customElements' in window) {
        customElements.define(tagName || 'dialog-toggle', DialogToggle);
      }
    }

    toggle;
    target;

    get expanded() {
      return this.toggle.getAttribute('aria-expanded') === 'true';
    };

    set expanded(to) {
      this.toggle.setAttribute('aria-expanded', to ? 'true' : 'false');

      if (to) {
        this.target.show();
      } else if (this.target.open) {
        this.target.close();
      }
    };

    togglePress = () => {
      this.expanded = !this.expanded;
    }

    #initialAttrs = () => {
      if (!this.toggle.hasAttribute('aria-expanded')) {
        this.expanded = this.target.getAttribute('open');
      }
    }

    connectedCallback() {
      this.toggle = this.querySelector(':scope > button');
      this.target = document.getElementById(this.toggle.getAttribute('aria-controls'));

      this.#initialAttrs();

      this.toggle.addEventListener('click', this.togglePress);
      this.target.addEventListener("close", () => this.expanded = false);
    }

    disconnectedCallback() {
      this.toggle.removeEventListener('click', this.togglePress);
    }
  }

  DialogToggle.register();</script>
  

</body>
</html>